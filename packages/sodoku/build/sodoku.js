"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Math", "clone"], [global, require('art-standard-lib')], (Math, clone) => {let allEncodedNumbers, allGroupsOk, isAllOk, squareNumberForLocation, get81XY, get9XY, eachElementInColumn, eachElementInRow, eachElementInSquare, isValidGroup, isAllValid, isLegalGroup, isAllLegal, identifyLegalPlacements, ilpCounts, resetIlpCounts, identifyLegalPlacementsInGroup, encodeNumber, addEncodedNumber, removeEncodedNumber, toggleEncodedNumber, hasEncodedNumber, subtractEncodedNumbers, mergeBoards, getLegalNumbers, getUnfinishedNumbers, getAllLegalNumbers, getAllUnfinishedNumbers, invLog2, solve, into1, i2; allEncodedNumbers = 0b111111111; return {allGroupsOk: allGroupsOk = function(board, eachElementInGroup, testEachElementInGroup) {let into, i1; return !(into = null, i1 = 0, (() => {while (i1 < 9) {let i; i = i1; if (into = !testEachElementInGroup(board, i, eachElementInGroup)) {break;}; i1++;};})(), into || null);}, isAllOk: isAllOk = function(board, testEachElementInGroup) {return allGroupsOk(board, eachElementInRow, testEachElementInGroup) && allGroupsOk(board, eachElementInColumn, testEachElementInGroup) && allGroupsOk(board, eachElementInSquare, testEachElementInGroup);}, squareNumberForLocation: squareNumberForLocation = function(x, y) {return (x / 3 | 0) + (y / 3 | 0) * 3;}, get81XY: get81XY = function(i81) {return [i81 % 9, i81 / 9 | 0];}, get9XY: get9XY = function(i9) {return [i9 % 3, i9 / 3 | 0];}, eachElementInColumn: eachElementInColumn = function(board, colNumber, f) {let i1; return (i1 = 0, (() => {while (i1 < 9) {let i; i = i1; f(board[i][colNumber], colNumber, i); i1++;};})(), 9);}, eachElementInRow: eachElementInRow = function(board, rowNumber, f) {let i1; return (i1 = 0, (() => {while (i1 < 9) {let i; i = i1; f(board[rowNumber][i], i, rowNumber); i1++;};})(), 9);}, eachElementInSquare: eachElementInSquare = function(board, squareNumber, f) {let x, y, i1; ([x, y] = get9XY(squareNumber)); return (i1 = 0, (() => {while (i1 < 9) {let c, i, j, yy, xx; c = i1; ([i, j] = get9XY(c)); f(board[yy = y * 3 + j][xx = x * 3 + i], xx, yy); i1++;};})(), 9);}, isValidGroup: isValidGroup = function(board, groupNumber, eachElementInGroup) {let encodedNumbers; encodedNumbers = 0; eachElementInGroup(board, groupNumber, (v) => encodedNumbers = addEncodedNumber(encodedNumbers, v)); return encodedNumbers === allEncodedNumbers;}, isAllValid: isAllValid = function(board) {return isAllOk(board, isValidGroup);}, isLegalGroup: isLegalGroup = function(board, groupNumber, eachElementInGroup) {let encodedNumbers, isLegal; encodedNumbers = 0; isLegal = true; eachElementInGroup(board, groupNumber, (v) => (v > 0) ? hasEncodedNumber(encodedNumbers, v) ? isLegal = false : encodedNumbers = addEncodedNumber(encodedNumbers, v) : undefined); return isLegal;}, isAllLegal: isAllLegal = function(board) {return isAllOk(board, isLegalGroup);}, identifyLegalPlacements: identifyLegalPlacements = true ? (ilpCounts = (into1 = [], i2 = 0, (() => {while (i2 < 9) {let v; v = i2; into1.push(0); i2++;};})(), into1), resetIlpCounts = function() {let i1; return (i1 = 0, (() => {while (i1 < 9) {let i; i = i1; ilpCounts[i] = 0; i1++;};})(), 9);}, identifyLegalPlacementsInGroup = function(board, result, groupNumber, eachElementInGroup) {let haveIllegalNumber; resetIlpCounts(); haveIllegalNumber = false; eachElementInGroup(board, groupNumber, (v, x, y) => {let c; return (v > 0) ? (1 < (c = ilpCounts[v] = ilpCounts[v] + 1)) ? haveIllegalNumber = true : undefined : undefined;}); return haveIllegalNumber ? eachElementInGroup(board, groupNumber, (v, x, y) => (ilpCounts[v] > 1) ? result[y][x] = false : undefined) : undefined;}, function(board) {let result, into, i, i3; result = (into = [], i = 0, (() => {while (i < 9) {let v, into2, i1; v = i; into.push((into2 = [], i1 = 0, (() => {while (i1 < 9) {let v1; v1 = i1; into2.push(true); i1++;};})(), into2)); i++;};})(), into); i3 = 0; while (i3 < 9) {let groupNumber; groupNumber = i3; identifyLegalPlacementsInGroup(board, result, groupNumber, eachElementInRow); identifyLegalPlacementsInGroup(board, result, groupNumber, eachElementInColumn); identifyLegalPlacementsInGroup(board, result, groupNumber, eachElementInSquare); i3++;}; 9; return result;}) : undefined, encodeNumber: encodeNumber = function(number) {return (number === 0) ? 0 : 1 << number - 1;}, addEncodedNumber: addEncodedNumber = function(numbers, number) {return numbers | encodeNumber(number);}, removeEncodedNumber: removeEncodedNumber = function(numbers, number) {return numbers & allEncodedNumbers - encodeNumber(number);}, toggleEncodedNumber: toggleEncodedNumber = function(numbers, number) {return numbers ^ encodeNumber(number);}, hasEncodedNumber: hasEncodedNumber = function(numbers, number) {return !!(numbers & encodeNumber(number));}, subtractEncodedNumbers: subtractEncodedNumbers = function(a, b) {return (a | b) ^ b;}, mergeBoards: mergeBoards = function(boardA, boardB) {return Caf.array(boardA, (row, y) => Caf.array(row, (number, x) => boardB[y][x] || boardA[y][x]));}, getLegalNumbers: getLegalNumbers = function(board, x, y) {let squareNumber, legalNumbers, f, x1, y1, i1, i3, i4; squareNumber = squareNumberForLocation(x, y); legalNumbers = allEncodedNumbers; f = (v) => legalNumbers = removeEncodedNumber(legalNumbers, v); i1 = 0; while (i1 < 9) {let i; i = i1; f(board[i][x]); i1++;}; 9; i3 = 0; while (i3 < 9) {let i; i = i3; f(board[y][i]); i3++;}; 9; ([x1, y1] = get9XY(squareNumber)); i4 = 0; while (i4 < 9) {let c, i, j; c = i4; ([i, j] = get9XY(c)); f(board[y1 * 3 + j][x1 * 3 + i]); i4++;}; 9; return legalNumbers;}, getUnfinishedNumbers: getUnfinishedNumbers = function(board, x, y) {let squareNumber, unfinishedNumbers, f, x1, y1, i1; squareNumber = squareNumberForLocation(x, y); unfinishedNumbers = allEncodedNumbers; f = (v) => unfinishedNumbers = removeEncodedNumber(unfinishedNumbers, v); ([x1, y1] = get9XY(squareNumber)); i1 = 0; while (i1 < 9) {let c, i, j; c = i1; ([i, j] = get9XY(c)); f(board[y1 * 3 + j][x1 * 3 + i]); i1++;}; 9; return unfinishedNumbers;}, getAllLegalNumbers: getAllLegalNumbers = function(board) {return Caf.array(board, (row, y) => Caf.array(row, (number, x) => (number > 0) ? 0 : getLegalNumbers(board, x, y)));}, getAllUnfinishedNumbers: getAllUnfinishedNumbers = function(board) {return Caf.array(board, (row, y) => Caf.array(row, (number, x) => getUnfinishedNumbers(board, x, y)));}, invLog2: invLog2 = 1 / Math.log(2), solve: solve = function(board, numSolutionsToReturn = 1) {let solutions, steps, recursiveSolver; solutions = []; steps = 0; recursiveSolver = (board, i81 = 0) => {let x, y, legalNumbers, into, i; ([x, y] = get81XY(i81)); steps++; return (() => {switch (false) {case !(0 === board[y][x]): return (0 !== (legalNumbers = getLegalNumbers(board, x, y))) ? (into = null, i = 1, (() => {while (i <= 9) {let n; n = i; if (into = hasEncodedNumber(legalNumbers, n) ? (board[y][x] = n, (80 === i81) ? solutions.push(clone(board)) : recursiveSolver(board, i81 + 1), board[y][x] = 0, (solutions.length >= numSolutionsToReturn) ? true : undefined) : undefined) {break;}; i++;};})(), into || null) || undefined : undefined; case !(80 === i81): solutions.push(clone(board)); return board; default: return recursiveSolver(board, i81 + 1);};})();}; recursiveSolver(clone(board)); return (numSolutionsToReturn > 1) ? solutions : solutions[0];}};});});
//# sourceMappingURL=sodoku.js.map
