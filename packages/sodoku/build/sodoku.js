"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Math", "clone"], [global, require('art-standard-lib')], (Math, clone) => {let allEncodedNumbers, isValidSequence, allRowsValid, allColumnsValid, allSquaresValid, isAllValid, encodeNumber, addEncodedNumber, removeEncodedNumber, toggleEncodedNumber, hasEncodedNumber, squareNumberForLocation, get81XY, get9XY, eachElementInColunn, eachElementInRow, eachElementInSquare, getLegalNumbers, invLog2, recursiveSolver, solve; allEncodedNumbers = 0b111111111; return {isValidSequence: isValidSequence = function(board, sequenceNumber, eachElementInSequence) {let encodedNumbers; encodedNumbers = 0; eachElementInSequence(board, sequenceNumber, (v) => encodedNumbers = addEncodedNumber(encodedNumbers, v)); return encodedNumbers === allEncodedNumbers;}, allRowsValid: allRowsValid = function(board) {let into, i1; return !(into = null, i1 = 0, (() => {while (i1 < 9) {let i; i = i1; if (into = !isValidSequence(board, i, eachElementInRow)) {break;}; i1++;};})(), into || null);}, allColumnsValid: allColumnsValid = function(board) {let into, i1; return !(into = null, i1 = 0, (() => {while (i1 < 9) {let i; i = i1; if (into = !isValidSequence(board, i, eachElementInColunn)) {break;}; i1++;};})(), into || null);}, allSquaresValid: allSquaresValid = function(board) {let into, i1; return !(into = null, i1 = 0, (() => {while (i1 < 9) {let i; i = i1; if (into = !isValidSequence(board, i, eachElementInSquare)) {break;}; i1++;};})(), into || null);}, isAllValid: isAllValid = function(board) {return allRowsValid(board) && allColumnsValid(board) && allSquaresValid(board);}, encodeNumber: encodeNumber = function(number) {return 1 << number - 1;}, addEncodedNumber: addEncodedNumber = function(numbers, number) {return numbers | encodeNumber(number);}, removeEncodedNumber: removeEncodedNumber = function(numbers, number) {return numbers & allEncodedNumbers - encodeNumber(number);}, toggleEncodedNumber: toggleEncodedNumber = function(numbers, number) {return numbers ^ encodeNumber(number);}, hasEncodedNumber: hasEncodedNumber = function(numbers, number) {return !!(numbers & encodeNumber(number));}, squareNumberForLocation: squareNumberForLocation = function(x, y) {return (x / 3 | 0) + (y / 3 | 0) * 3;}, get81XY: get81XY = function(i81) {return [i81 % 9, i81 / 9 | 0];}, get9XY: get9XY = function(i9) {return [i9 % 3, i9 / 3 | 0];}, eachElementInColunn: eachElementInColunn = function(board, colNumber, f) {let i1; return (i1 = 0, (() => {while (i1 < 9) {let i; i = i1; f(board[i][colNumber]); i1++;};})(), 9);}, eachElementInRow: eachElementInRow = function(board, rowNumber, f) {let i1; return (i1 = 0, (() => {while (i1 < 9) {let i; i = i1; f(board[rowNumber][i]); i1++;};})(), 9);}, eachElementInSquare: eachElementInSquare = function(board, squareNumber, f) {let x, y, i1; ([x, y] = get9XY(squareNumber)); return (i1 = 0, (() => {while (i1 < 9) {let c, i, j; c = i1; ([i, j] = get9XY(c)); f(board[y * 3 + j][x * 3 + i]); i1++;};})(), 9);}, getLegalNumbers: getLegalNumbers = function(board, x, y) {let squareNumber, illegalNumbers; squareNumber = squareNumberForLocation(x, y); illegalNumbers = 0; eachElementInColunn(board, x, (v) => (v > 0) ? illegalNumbers = addEncodedNumber(illegalNumbers, v) : undefined); eachElementInRow(board, y, (v) => (v > 0) ? illegalNumbers = addEncodedNumber(illegalNumbers, v) : undefined); eachElementInSquare(board, squareNumber, (v) => (v > 0) ? illegalNumbers = addEncodedNumber(illegalNumbers, v) : undefined); return allEncodedNumbers - illegalNumbers;}, invLog2: invLog2 = 1 / Math.log(2), recursiveSolver: recursiveSolver = function(board, i81 = 0) {let x, y, legalNumbers, into, i; ([x, y] = get81XY(i81)); return (() => {switch (false) {case !(0 === board[y][x]): return (0 !== (legalNumbers = getLegalNumbers(board, x, y))) ? (into = null, i = 1, (() => {while (i <= 9) {let n, result; n = i; if (into = hasEncodedNumber(legalNumbers, n) ? (board[y][x] = n, (() => {switch (false) {case !(80 === i81): return board; case !(result = recursiveSolver(board, i81 + 1)): return result; default: board[y][x] = 0; return undefined;};})()) : undefined) {break;}; i++;};})(), into || null) || undefined : undefined; case !(80 === i81): return board; default: return recursiveSolver(board, i81 + 1);};})();}, solve: solve = function(board) {return recursiveSolver(clone(board));}};});});
//# sourceMappingURL=sodoku.js.map
