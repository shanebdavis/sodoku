import &ArtStandardLib

allLegalNumbers = 0b111111111 # 9 1-bits

{}
  ###################################
    Handy Validators; not essential
  ###################################
  isValidSequence = (board, sequenceNumber, eachElementInSequence) ->
    num = 0
    eachElementInSequence board, sequenceNumber, (v) -> num += 1 << (v - 1)
    num == allLegalNumbers

  allRowsValid    = (board) -> !find i til 9 with !isValidSequence board, i, eachElementInRow
  allColumnsValid = (board) -> !find i til 9 with !isValidSequence board, i, eachElementInColunn
  allSquaresValid = (board) -> !find i til 9 with !isValidSequence board, i, eachElementInSquare

  isAllValid = (board) ->
    allRowsValid board
    && allColumnsValid board
    && allSquaresValid board

  ###################################
    Essential Solver
  ###################################
  squareNumberForLocation = (x, y)  -> (x / 3 | 0) + (y / 3 | 0) * 3
  get81XY                 = (i81)   -> i81 % 9, i81 / 9 | 0
  get9XY                  = (i9)    -> i9  % 3, i9  / 3 | 0

  eachElementInColunn = (board, colNumber, f) -> each i til 9 with f board[i][colNumber]
  eachElementInRow    = (board, rowNumber, f) -> each i til 9 with f board[rowNumber][i]

  eachElementInSquare = (board, squareNumber, f) ->
    [x, y] = get9XY squareNumber
    each c til 9
      [i, j] = get9XY c
      f board[y * 3 + j][x * 3 + i]

  getLegalNumbers = (board, x, y) ->
    squareNumber = squareNumberForLocation x, y
    illegalNumbers = 0
    eachElementInColunn board, x,            (v) -> if v > 0 then illegalNumbers |= 1 << (v - 1)
    eachElementInRow    board, y,            (v) -> if v > 0 then illegalNumbers |= 1 << (v - 1)
    eachElementInSquare board, squareNumber, (v) -> if v > 0 then illegalNumbers |= 1 << (v - 1)
    allLegalNumbers - illegalNumbers

  invLog2 = 1 / Math.log(2)

  recursiveSolver = (board, i81 = 0)  ->
    [x, y] = get81XY i81
    switch
    when 0 == board[y][x]
      if 0 != legalNumbers = getLegalNumbers board, x, y
        find i til 9
          if legalNumbers & (1 << i)
            board[y][x] = i + 1
            switch
            when 80 == i81 then board
            when result = recursiveSolver board, i81 + 1 then result
            else
              board[y][x] = 0
              undefined

        || undefined

    when 80 == i81 then board
    else recursiveSolver board, i81 + 1

  ## solve
    IN:   board: sodoku board (9 arrays of 9 the numbers 0 to 9; 0 implies a non-filled-in-slot)
    OUT:  if possible, then a fully solved board, else undefined
  solve = (board, a) -> recursiveSolver clone board
